#!/usr/bin/python

from __future__ import print_function
from spacewalk.common.rhnConfig import CFG, initCFG
from spacewalk.common.rhnLog import initLOG, log_debug, log_error
from spacewalk.server import rhnSQL
from datetime import datetime
import time
import os
import rpm
import sys
from io import StringIO

LOG_FILE = '/var/log/rhn/align-rpm-buildtime.log'
initLOG(LOG_FILE, 1)

initCFG('server')
_package_path_prefix = CFG.MOUNT_POINT

#
# - find first sync after install/update to 3.1
# - get the list of package ids created after install/update to 3.1
#
_query_all_possible_affected_packages = rhnSQL.Statement("""
    select
        p.id,
        p.path,
        p.build_time,
        pn.name
    from rhnpackage p
        join rhnPackageName pn
            on p.name_id = pn.id
    where created >=
    (
        select
            min(created)
        from rhnVersionInfo vi
            join rhnPackageEVR evr
                on vi.evr_id = evr.id
        where evr.version like '3.1.%'
    )
""")

def get_all_possible_affected_packages():
    h = rhnSQL.prepare(_query_all_possible_affected_packages)
    h.execute()
    affected_packages = h.fetchall_dict()
    return affected_packages

#
# - find rpm via "path", parse the correct build time
#
def get_rpm_tag_build_time(rpm_file):
    """Returns rpm information by querying a rpm"""
    # open .rpm file
    fd = os.open(rpm_file, os.O_RDONLY)

    # init transaction set
    transaction_set = rpm.TransactionSet()

    # handle exception in case of an rpm with no-signatures
    try:
        # read header
        hdr = transaction_set.hdrFromFdno(fd)
    except rpm.error:
        # closing and reopening rpm file
        # prevents the 'too many open files' error
        os.close(fd)
        fd = os.open(rpm_file, os.O_RDONLY)

        # adjust the transaction_set to read an rpm with no-signatures
        transaction_set.setVSFlags(rpm._RPMVSF_NOSIGNATURES)

        # read header
        hdr = transaction_set.hdrFromFdno(fd)

    # close file
    os.close(fd)

    return hdr[rpm.RPMTAG_BUILDTIME]


#
# - update package build_time in DB
#
_update_package_build_time = rhnSQL.Statement("""
    update rhnPackage
    set build_time = :build_time
    where id = :id
""")

def update_package_build_time_by_id(id, build_time):
    h = rhnSQL.prepare(_update_package_build_time)
    ret = h.execute(id=id, build_time=build_time)
    return ret


#
# - delete package repodata snippet from DB
#
_delete_repodata_snippet_by_id = rhnSQL.Statement("""
    delete
    from rhnPackageRepodata
    where package_id = :id
""")

def delete_repodata_snippet_by_id(id):
    h = rhnSQL.prepare(_delete_repodata_snippet_by_id)
    ret = h.execute(id=id)
    return ret


#
# - trigger regeneration of all metadata for all channels
#
_insert_trigger_to_regenerate_metadata_for_all_channels = rhnSQL.Statement("""
    insert into rhnRepoRegenQueue (id, CHANNEL_LABEL, REASON, FORCE)
    (
        select
            sequence_nextval('rhn_repo_regen_queue_id_seq'),
            C.label,
            'align rpm build_time by script for bsc1078056',
            'Y'
        from rhnChannel C
    )
""")

def regenerate_metadata_for_all_channels():
    h = rhnSQL.prepare(_insert_trigger_to_regenerate_metadata_for_all_channels)
    ret = h.execute()
    return ret


def assert_rpm_pkg(pkg_data):
    '''
    Checks if the RPM package is there, prior adding a mount point
    '''
    err = None
    if not CFG.MOUNT_POINT:
        err = 'Mount point is not configured in the configuration'
    elif not pkg_data.get('path'):
        pkg_name = pkg.data.get('name')
        if not pkg_name:
            err = 'Package name was not found'
        else:
            err = 'Path not found for the RPM package "{0}".'.format(pkg_name)
    pkg_path = os.path.join(CFG.MOUNT_POINT, pkg_data.get('path'))
    if not err and not os.path.exists(pkg_path):
        err = 'RPM file was not found at "{0}"'.format(pkg_path)
    if err:
        raise OSError(err)

    return pkg_path

#
# the main
#
if __name__ == '__main__':
    
    rhnSQL.initDB()

    something_changed = False

    # find all packages
    package_list = get_all_possible_affected_packages()

    if package_list is not None:
        log_debug(1, 'Scanning %s packages' % len(package_list))
        sys.stdout.write('Scanning %s packages' % len(package_list))
        sys.stdout.write('\n')

        # iterate on each package
        for index, package_blob in enumerate(package_list):

            package_id = package_blob['id']

            # get the absolute path of the package on the filesystem
            absolute_package_path = os.path.join(_package_path_prefix, package_blob['path'])

            # extract the rpm_tag_build_time from the rpm
            rpm_tag_build_time = datetime(*time.gmtime(get_rpm_tag_build_time(absolute_package_path))[:6])

            # compare RPM vs DB "buildtime"s
            if package_blob['build_time'] != rpm_tag_build_time:

                # update the row in DB
                ret = update_package_build_time_by_id(package_id, rpm_tag_build_time)
                if ret == 1:
                    log_debug(1, 'build_time updated for the package id %s' % package_id)
                    something_changed = True
                else:
                    log_error('something went wrong during update of the build_time for the package id %s' % package_id)

                # remove the stored metadata snippet for this package
                ret = delete_repodata_snippet_by_id(package_id)
                if ret == 1:
                    log_debug(1, 'repodata snipped removed for the package id %s' % package_id)
                    something_changed = True
                else:
                    log_error('something went wrong during remove of the repodata snippet for the package id %s' % package_id)

            if index % 100 == 0:
                rhnSQL.commit()
                sys.stdout.write('.')
                sys.stdout.flush()

        sys.stdout.write('\n')

        # finally trigger regeneration of all metadata for all channels
        if something_changed:
            ret = regenerate_metadata_for_all_channels()
            log_debug(1, 'queued %s channel metadata regeneration' % ret)
            sys.stdout.write('queued %s channel metadata regeneration' % ret)
            sys.stdout.write('\n')

        rhnSQL.commit()
    else:
        sys.stdout.write('Nothing to do.')
        sys.stdout.write('\n')

