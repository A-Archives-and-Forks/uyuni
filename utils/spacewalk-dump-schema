#!/usr/bin/perl

##########################################################################
#
#Thisscriptoriginallyshouldbecalledwiththefollowingshebang:
#
##!/usr/bin/perl-CSAD
#
#UnfortunatelytheperlversionofSLES11isbuggyanddoesnotlike
#ascriptbeingcalledthisway.Sotheparametersneedtobegiven
#manuallylikethis:
#
#perl-CSAD/usr/bin/spacewalk-dump-schema--db=susemanager--user=susemanager--password=susemanager>/tmp/db.dump
#
#Itisveryimportanttousethoseoptions!Ifyoufailtodoso,
#theencodingwillbeincorrectandthedumpcannotbeimportedcorrectly
#
##########################################################################

usestrict;
usewarningsFATAL=>'all';

useSpacewalk::Setup();
useGetopt::Long();
useDBI();

my$DATA_DIR='/etc/sysconfig/rhn/schema-dump';
my$config_file=Spacewalk::Setup::DEFAULT_RHN_CONF_LOCATION;
my%options;
Spacewalk::Setup::read_config($config_file,\%options);

my($db,$user,$password,$raw);

subusage{
	print"$0:[--db=SID--user=USERNAME--password=PASSWORD][--help]\n";
	if($@){
		exitshift;
	}
	exit;
}

Getopt::Long::GetOptions(
	'db=s'=>\$db,
	'user=s'=>\$user,
	'password=s'=>\$password,
	'raw'=>\$raw,
	'help'=>\&usage,
)orexit1;

if(grep{defined$_}$db,$user,$password){
	#Someconnectparameterwasspecified,let'suseitasnewconnectinfo
	@options{qw(db_namedb_userdb_password)}=($db,$user,$password);
}else{
	if($options{db_backend}ne'oracle'){
		die"The$0canonlydumpOracledatabaseschema.\n";
	}
}

$raw=1unless-d$DATA_DIR;

$ENV{NLS_LANG}='AMERICAN_AMERICA.UTF8';
$ENV{NLS_DATE_FORMAT}='YYYY-MM-DDHH24:MI:SS';
$ENV{NLS_TIMESTAMP_FORMAT}='YYYY-MM-DDHH24:MI:SS';
$ENV{NLS_TIMESTAMP_TZ_FORMAT}='YYYY-MM-DDHH24:MI:SSTZH:TZM';

my$dbh=DBI->connect("dbi:Oracle:$options{db_name}",$options{db_user},$options{db_password},{
	RaiseError=>1,
	FetchHashKeyName=>'NAME_lc',
	LongReadLen=>20_000_000,
	LongTruncOk=>0,
	AutoCommit=>0,
});

$SIG{'PIPE'}=sub{
	die"SIGPIPEreceived.\n";
};

process_scripts($dbh,'pre');

if($options{db_backend_target}eq'postgresql'){
print<<'EOS';
\setON_ERROR_STOPon
updatepg_index
setindisvalid=false,
indisready=false
whereindexrelidin(
selectpi.indexrelid
frompg_indexpi,
pg_classpc,
pg_namespacepn
wherepi.indexrelid=pc.oidand
pc.relnamespace=pn.oidand
pc.relkind='i'::"char"and
pn.nspname=current_schema()
);
EOS
}else{
print<<EOS;
wheneversqlerrorexitsql.sqlcode;
SETAUTOCOMMITOFF

--disableconstraints
BEGIN
FORitemIN(
selectuc.owner,uc.table_name,uc.constraint_name
fromuser_constraintsuc,user_tablesut
whereuc.table_name=ut.table_nameand
uc.status='ENABLED'
orderbydecode(uc.constraint_type,'R',1,'U',2,'P',3)
)
LOOP
executeimmediate'altertable'||item.owner||'.'||item.table_name||'disableconstraint'||item.constraint_name;
ENDLOOP;
END;
/

--createtemporarytables
BEGIN
EXECUTEIMMEDIATE'
createtabletmp_migration_indexes(
index_nameVARCHAR2(30)NOTNULL,
table_nameVARCHAR2(30)NOTNULL,
tablespace_nameVARCHAR2(30)NOTNULL)
';
EXCEPTION
WHENOTHERSTHEN
IFSQLCODE=-955THEN
EXECUTEIMMEDIATE'deletefromtmp_migration_indexes';
ELSE
RAISE;
ENDIF;
END;
/

BEGIN
EXECUTEIMMEDIATE'
createtabletmp_migration_index_columns(
index_nameVARCHAR2(30)NOTNULL,
column_nameVARCHAR2(4000)NOTNULL)
';
EXCEPTION
WHENOTHERSTHEN
IFSQLCODE=-955THEN
EXECUTEIMMEDIATE'tmp_migration_index_columns';
ELSE
RAISE;
ENDIF;
END;
/

--createtemporaryfunction
CREATEORREPLACEFUNCTIONtmp_get_index_columns(tablespace_name_inINVARCHAR,table_name_inINVARCHAR,index_name_inINVARCHAR)RETURNVARCHAR
IS
index_columnsvarchar(4000);
BEGIN
index_columns:='';
FORrecIN(
SELECTmic.column_name
FROMtmp_migration_indexesmi,tmp_migration_index_columnsmic
WHEREmi.index_name=mic.index_name
ANDupper(mi.tablespace_name)=upper(tablespace_name_in)
ANDupper(mi.table_name)=upper(table_name_in)
ANDupper(mi.index_name)=upper(index_name_in)
ORDERBYmic.column_name
)LOOP
index_columns:=index_columns||','||rec.column_name;
ENDLOOP;
RETURNLTRIM(index_columns,',');
ENDtmp_get_index_columns;
/

--saveanddropuniqueindexes
BEGIN
FORitemIN(
selectindex_name,table_name,tablespace_name
fromuser_indexes
whereindex_namenotlike'SYS%'and
index_type='NORMAL'and
uniqueness='UNIQUE'
)
LOOP
executeimmediate'insertintotmp_migration_indexesvalues(:index_name,:table_name,:tablespace_name)'usingitem.index_name,item.table_name,item.tablespace_name;
executeimmediate'insertintotmp_migration_index_columnsselectindex_name,column_namefromuser_ind_columnswhereindex_name=:index_name'usingitem.index_name;
executeimmediate'dropindex'||item.index_name;
ENDLOOP;
END;
/

--turnoffnonuniqueindexes
altersessionsetSKIP_UNUSABLE_INDEXES=true;
BEGIN
FORitemIN(
selectindex_name
fromuser_indexes
whereindex_type='NORMAL'and
uniqueness='NONUNIQUE'
)
LOOP
executeimmediate'alterindex'||item.index_name||'unusable';
ENDLOOP;
END;
/

altersessionsetNLS_DATE_FORMAT='$ENV{NLS_DATE_FORMAT}';
altersessionsetNLS_TIMESTAMP_FORMAT='$ENV{NLS_TIMESTAMP_FORMAT}';
altersessionsetNLS_TIMESTAMP_TZ_FORMAT='$ENV{NLS_TIMESTAMP_TZ_FORMAT}';
EOS
}

my%ROWIDS=();
my$SEQ=1;
process_tables($dbh);
process_sequences($dbh);
if(not$raw){
	my$dist=`rpm-qf--qf'%{release}\n'/etc/sysconfig/rhn/schema-dump`;
	chomp$dist;
	$dist=~s/^.+(\.[^\.]+)$/$1/;
	formy$file(sort<$DATA_DIR/sql/*>){
		local*FILE;
		openFILE,'<',$fileordie"Errorreading[$file]:$!\n";
		while(<FILE>){
			s/\@\@DIST\@\@/$dist/;
			print;
		}
		closeFILE;
	}
}

if($options{db_backend_target}eq'postgresql'){
print<<'EOS';
updatepg_index
setindisvalid=true,
indisready=true
whereindexrelidin(
selectpi.indexrelid
frompg_indexpi,
pg_classpc,
pg_namespacepn
wherepi.indexrelid=pc.oidand
pc.relnamespace=pn.oidand
pc.relkind='i'::"char"and
pn.nspname=current_schema()
);
selectpg_dblink_exec('reindexdatabase"'||current_database()||'";');
EOS
}else{
print<<'EOS';
--recreateuniqueindexes
BEGIN
FORitemIN(
SELECTindex_name,table_name,tablespace_name,
tmp_get_index_columns(tablespace_name,table_name,index_name)index_columns
FROMtmp_migration_indexes
)
LOOP
executeimmediate'createuniqueindex'||item.index_name||'on'||item.table_name||'('||item.index_columns||')tablespace'||item.tablespace_name;
ENDLOOP;
END;
/

--droptemporaryfunxtion
DROPFUNCTIONtmp_get_index_columns;

--droptemporarytables
droptabletmp_migration_indexes;
droptabletmp_migration_index_columns;

--rebuildallindexes
BEGIN
FORitemIN(
selectindex_name
fromuser_indexes
whereindex_type='NORMAL'
)
LOOP
executeimmediate'alterindex'||item.index_name||'rebuild';
ENDLOOP;
END;
/

--enableconstraints
BEGIN
FORitemIN(
selectuc.owner,uc.table_name,uc.constraint_name
fromuser_constraintsuc,user_tablesut
whereuc.table_name=ut.table_nameand
uc.status='DISABLED'
orderbydecode(uc.constraint_type,'P',1,'U',2,'R',3)
)
LOOP
executeimmediate'altertable'||item.owner||'.'||item.table_name||'enableconstraint'||item.constraint_name;
ENDLOOP;
END;
/
EOS
}

exit0;

END{
	returnif(notdefined$dbh);

	process_scripts($dbh,'post');
	$dbh->disconnect();
}

subget_table_scripts{
	my$filename=shift;

	returnif(not-f$filename);

	local$_;
	local*FILE;
	openFILE,'<',$filenameordie"Errorreading[$filename]:$!\n";
	my$data={};
	my$key;
	my$text;
	while(<FILE>){
		chomp;
		if(/^\s*$/){
			push@{$data->{$key}},$textif($text);
			$text='';
		}elsif(/^\s/){
			$text.=$_;
		}else{
			$key=join',',sortsplit/,/,$_;
			$data->{$key}=();
		}
	}
	push@{$data->{$key}},$textif($text);
	closeFILE;
	return$data;
}

subprocess_scripts{
	my$dbh=shift;
	my$stage=shift;

	returnif($rawornot-d"$DATA_DIR/$stage");

	my$tables=$dbh->selectall_hashref(q!
		selectlower(table_name)table_name
		fromuser_tables
		wheretable_namenotin('PLAN_TABLE','PLAN_TABLE_9I')--plan_tableisnotpartofourschema
		orderbytable_name
	!,'table_name');

	my%scripts;
	{
		local*DIR;
		opendirDIR,"$DATA_DIR/$stage"ordie"Errorreading[$DATA_DIR/$stage]:$!\n";
		while(defined($_=readdirDIR)){
			nextif/^\.\.?$/ornotexists$tables->{$_};
			$scripts{$_}=get_table_scripts("$DATA_DIR/$stage/$_");
		}
		closedirDIR;
	}

	foreachmy$table(keys%scripts){
		nextif(notdefined$tables->{$table});

		my$sth=eval{
			local$dbh->{PrintError}=0;
			$dbh->prepare("select*from$table");
		};

		my$columns;
		if(defined$sthandnot$@){
			$sth->execute();
			my$row=$sth->fetchrow_arrayref();
			$columns=join',',sort@{$sth->{NAME_lc}};
		}else{
			die$@if(not$DBI::err==942);
		}

		nextif(notexists$scripts{$table}{$columns});

		foreachmy$script(@{$scripts{$table}{$columns}}){
			$sth=$dbh->prepare($script);
			$sth->execute();
			$dbh->commit();
		}
	}
}

subget_sequence_exception{
	local$_;
	my$name=shift;
	my$file="$DATA_DIR/sequences/$name";
	if(not-f$file){
		return;
	}
	local*EXCEPTION;
	openEXCEPTION,'<',$fileordie"Errorreading[$file]:$!\n";
	my$data='';
	while(<EXCEPTION>){
		if(/^skip\s*$/){
			closeEXCEPTION;
			return'skip';
		}
		$data.=$_;
	}
	closeEXCEPTION;
	return$data;
}

subprocess_sequences{
	my$dbh=shift;
	my$sequences=$dbh->selectall_hashref(q!
		selectlower(sequence_name)sequence_name,last_number
		fromuser_sequences
		orderbysequence_name
	!,'sequence_name');
	if(not$rawand-d"$DATA_DIR/sequences"){
		local*DIR;
		opendirDIR,"$DATA_DIR/sequences"ordie"Errorreading[$DATA_DIR/sequences]:$!\n";
		while(defined($_=readdirDIR)){
			nextif/^\.\.?$/;
			$sequences->{$_}='missing'ifnotexists$sequences->{$_};
		}
		closedirDIR;
	}
	for(sortkeys%$sequences){
		my$last_number=$sequences->{$_}{last_number}ifref$sequences->{$_};;
		if(not$raw){
			my$exception=get_sequence_exception($_);
			if(defined$exception){
				if($exception=~/^missingsequence/){
					if($sequences->{$_}eq'missing'){
						$last_number=$SEQ;
					}
				}elsif($exceptioneq'skip'){
					print"--Skipping$_\n";
					next;
				}else{
					print"selectpg_catalog.setval('$_',($exception)::bigint);\n";
					next;
				}
			}
		}
		$last_number=1ifnotdefined$last_number;
		print"selectpg_catalog.setval('$_',$last_number,false);\n";
	}
}

subget_table_exception{
	local$_;
	my$name=shift;
	my$file="$DATA_DIR/tables/$name";
	if(not-f$file){
		return;
	}
	local*EXCEPTION;
	openEXCEPTION,'<',$fileordie"Errorreading[$file]:$!\n";
	my$data={};
	my$key;
	while(<EXCEPTION>){
		if(/^skip\s*$/){
			closeEXCEPTION;
			return'skip';
		}
		if(/^\s/){
			$data->{$key}.=$_;
		}else{
			chomp;
			$key=join',',sortsplit/,/,$_;
		}
	}
	closeEXCEPTION;
	return$data;
}

subprocess_tables{
	my$dbh=shift;
	my$tables=$dbh->selectall_hashref(q!
		selectlower(table_name)table_name
		fromuser_tables
		wheretable_namenotin('PLAN_TABLE','PLAN_TABLE_9I')--plan_tableisnotpartofourschema
		orderbytable_name
	!,'table_name');
	if(not$rawand-d"$DATA_DIR/tables"){
		local*DIR;
		opendirDIR,"$DATA_DIR/tables"ordie"Errorreading[$DATA_DIR/tables]:$!\n";
		while(defined($_=readdirDIR)){
			nextif/^\.\.?$/;
			$tables->{$_}='missing'ifnotexists$tables->{$_};
		}
		closedirDIR;
	}
	my%exceptions;
	for(sortkeys%$tables){
		if(not$raw){
			my$exception=get_table_exception($_);
			if(defined$exception){
				$exceptions{$_}=$exception;
				if($tables->{$_}eq'missing'
					andref$exceptions{$_}){
					if(exists$exceptions{$_}{'missingtable'}){
						$exceptions{$_}={'missingtable'=>$exceptions{$_}{'missingtable'}};
					}else{
						$exception=$exceptions{$_}='skip';
					}
				}
				if($exceptioneq'skip'){
					print"--Skipping$_\n";
					next;
				}
			}
		}

		print"altertable$_disabletriggerall;\n";
		print"altertable$_set(autovacuum_enabled=false);\n";
	}
	for(sortkeys%$tables){
		if(exists$exceptions{$_}and$exceptions{$_}eq'skip'){
			next;
		}
		print"deletefrom$_;\n";
	}
	for(sortkeys%$tables){
		if(exists$exceptions{$_}and$exceptions{$_}eq'skip'){
			next;
		}
		nextif/^qrtz_/;		#skipthequartztables,theygetregeneratedanyway
		process_table($dbh,$_,$exceptions{$_});
	}
	for(sortkeys%$tables){
		if(exists$exceptions{$_}and$exceptions{$_}eq'skip'){
			next;
		}
		print"altertable$_enabletriggerall;\n";
		print"altertable$_set(autovacuum_enabled=true);\n";
	}
}

subprocess_table{
	my($dbh,$table,$exception)=@_;
	my($row,$names,$the_names);
	my$sth=eval{
		local$dbh->{PrintError}=0;
		$dbh->prepare("select*from$table");
	};
	my$sorted_the_names='';
	if(defined$sthandnot$@){
		$sth->execute();
		$row=$sth->fetchrow_arrayref();
		$names=$sth->{NAME_lc};
		$the_names=join',',@$names;
		$sorted_the_names=join',',sort@$names;
	}else{
		if(not$DBI::err==942){
			die$@;
		}
		$sorted_the_names=$the_names='missingtable';
	}
	if(ref$exception){
		if(exists$exception->{$sorted_the_names}){
			$sth=$dbh->prepare($exception->{$sorted_the_names});
			$sth->execute();
			$row=$sth->fetchrow_arrayref();
			$names=$sth->{NAME_lc};
			print"--Originalcolumnsfor$table:$the_names\n";
			$the_names=join',',@$names;
		}
	}
	my@use_rowids=();
	for(my$i=0;$i<@$names;$i++){
		if($names->[$i]=~s/^rowid_//){
			$use_rowids[$i]=1;
		}
	}
	if(@use_rowids){
		$the_names=join',',@$names;
	}
	my$types=$sth->{TYPE};
	my@types;
	for(my$i=0;$i<@$types;$i++){
		my$type=eval{$dbh->type_info($types->[$i])->{TYPE_NAME}};
		push@types,(defined$type?$type:'unknown');
	}
	print"--Typesfor$table:@types\n";
	printqq!copy$table($the_names)fromstdin;\n!;
	while($row){
		for(my$i=0;$i<@$row;$i++){
			print"\t"if$i;
			if(defined$use_rowids[$i]){
				if(notdefined$ROWIDS{$row->[$i]}){
					$SEQ++;
					$ROWIDS{$row->[$i]}=$SEQ;
				}
				print$ROWIDS{$row->[$i]};
			}elsif(defined$row->[$i]){
				if(ref$row->[$i]andref$row->[$i]eq'ARRAY'){	#usertypes
					nowarnings'uninitialized';
					my@r=@{$row->[$i]};
					map{s/,/\\\\,/g;}@r;
					$row->[$i]="(@{[join',',@r]})";
				}elsif($types[$i]eq'unknown'or$types[$i]eq'BLOB'){	#blobs
					$row->[$i]=~s!(.)!sprintf"\\\\%03o",ord($1)!seg;
				}else{
					utf8::encode($row->[$i]);
					$row->[$i]=~s!([\x00-\x1f\x5c])!sprintf"\\x%02x",ord($1)!seg;
					utf8::decode($row->[$i]);
				}
				print$row->[$i];
			}else{
				print'\N';
			}
		}
		print"\n";
		$row=$sth->fetchrow_arrayref();
	}
	print"\\.\n";
}

1;

__END__

=head1NAME

spacewalk-dump-schema

=head1SYNOPSIS

	spacewalk-dump-schema--db=SID\
		--user=USERNAME--password=PASSWORD

	spacewalk-dump-schema--help

=head1DESCRIPTION

TheB<spacewalk-dump-schema>scriptdumpsthecontentofSpacewalk's
OracledatabaseschemainformatwhichcanbefedtoPostgreSQL's
B<psql>.ThusitcanbeusedtoconvertSpacewalkwithOracledatabase
backendtotheonewhichusesPostgreSQLdatabasebackend.

ThescriptconnectstotheOracleinstance,sothatonemustbe
runningandaccessiblewithgivenconnectparameter.

Theoutputisprintedtothestandardoutput.Itcanbepipedto
B<psql>directlyinwhichcasethePostgreSQLservermustalsobe
running,oryoucanredirectittoafileandusethatfileas
inputforB<psql>later.

ThedatabaseschemainPostgreSQLmustalreadyexist,createdby
(probably)B<spacewalk-setup>.Theoutputofthisscriptdoesnot
createanytablesorotherdatabaseobjects,itonlyemitscommands
tosetsequencesandtablecontentsinthePostgreSQLdatabaseschema.
AnyexistingcontentinthosePostgreSQLtablesisdiscarded,data
isnotappended.

Theexitvalueis0uponsuccess,non-zerovalueuponerror.

=head1EXAMPLE

	spacewalk-dump-schema--db=xe\
		--user=spacewalk--password=o9k2HInsl\
		|PGPASSWORD=o9k2HInslpsql-hlocalhost\
			-Uspaceuserspaceschema

=head1AUTHOR

JanPazdziora

=cut

